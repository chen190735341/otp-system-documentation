# 2 系统原理
## 2.1 系统原理
### 2.1.1 系统启动

Erlang的运行环境(runtime system)通过命令`erl`启动：

    % erl
    Erlang/OTP 17 [erts-6.0] [hipe] [smp:8:8]
    Eshell V6.0 (abort with ^G)
    1>
    
erl有许多启动参数，具体可以参见`erl(1)`。本章将对部分参数进行介绍。

erlang应用程序可以通过函数`init:get_argument(Key)`，`init:get_arguments()`获取命令行参数。参见`init(3)`。

### 2.1.2 重启和退出

Erlang系统可以通过调用`halt/0,1`退出。参见`erlang(3)`。

`init`模块包含重新启动(restarting）、重新引导（rebooting）和停止（stopping）Erlang运行环境的函数。参见`init(3)`。

    init:restart()
    init:reboot()
    init:stop()
    
另外Erlang外壳（shell）如果停止，Erlang运行时也将停止。

### 2.1.3 启动脚本

Erlang运行环境依赖启动脚本（`boot script`）进行启动。启动脚本包含了需要加载的代码、进程和应用的指令。

启动脚本的扩展名是`.script`。Erlang系统启动是用的是二进制版本的启动脚本，它的扩展名为`.boot`。

用命令行参数`-boot`指定用哪个启动脚本启动Erlang。启动脚本的扩展名`.boot`必须省略。例如，用start_all.boot启动：

    % erl -boot start_all
    
如果没有指定启动脚本，erl将用默认的启动脚本，即：`ROOT/bin/start`进行启动。下面展示了默认启动脚本的内容。

通过命令行参数`-init_debug`可以让`init`进行在处理启动脚本时打印相应调试信息。

    % erl -init_debug
    {progress,preloaded}
    {progress,kernel_load_completed}
    {progress,modules_loaded}
    {start,heart}
    {start,error_logger}
    ...
    
启动脚本的具体内容和语法描述参见`script(4)`
  
**默认启动脚本**
  
Erlang/OTP自带了两个启动脚本：
  
- `start_clean.boot`
:    加载并启动Kernel和STDLIB
- `start_sasl.boot`
:    加载并启动Kernel、STDLIB和SASL
- `no_dot_erlang.boot`
:    加载并启动Kernel、STDLIB，但是不加载`.erlang`文件。这对于那些忽略用户自定义环境的脚本和工具非常有用。

在用`Install`安装Erlang/OTP时，程序会询问：“你希望精简启动，还是SASL启动？”，用以指定默认使用`start_clean`还是`start_sasl`启动脚本。如果你回答前者，则Erlang将用`start_clean`反之则用`start_sasl`。安装程序将复制你指定的启动脚本到`ROOT/bin`目录下，并命名为`start.boot`作为默认启动脚本。

**用户自定义启动脚本**

有时候创建自定义的启动脚本非常有用并且有必要。尤其是在嵌入式模式下运行Erlang，参见`代码加载策略(Code Loading Strategy)`。


  

  
  




