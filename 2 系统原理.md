* auto-gen TOC:
{:toc}

# 2 系统原理
## 2.1 系统原理
### 2.1.1 系统启动

Erlang的运行环境(runtime system)通过命令`erl`启动：

    % erl
    Erlang/OTP 17 [erts-6.0] [hipe] [smp:8:8]
    Eshell V6.0 (abort with ^G)
    1>
    
erl有许多启动参数，具体可以参见`erl(1)`。本章将对部分参数进行介绍。

erlang应用程序可以通过函数`init:get_argument(Key)`，`init:get_arguments()`获取命令行参数。参见`init(3)`。

### 2.1.2 重启和退出

Erlang系统可以通过调用`halt/0,1`退出。参见`erlang(3)`。

`init`模块包含重新启动(restarting）、重新引导（rebooting）和停止（stopping）Erlang运行环境的函数。参见`init(3)`。

    init:restart()
    init:reboot()
    init:stop()
    
另外Erlang外壳（shell）如果停止，Erlang运行时也将停止。

### 2.1.3 启动脚本

Erlang运行环境依赖启动脚本（`boot script`）进行启动。启动脚本包含了需要加载的代码、进程和应用的指令。

启动脚本的扩展名是`.script`。Erlang系统启动是用的是二进制版本的启动脚本，它的扩展名为`.boot`。

用命令行参数`-boot`指定用哪个启动脚本启动Erlang。启动脚本的扩展名`.boot`必须省略。例如，用start_all.boot启动：

    % erl -boot start_all
    
如果没有指定启动脚本，erl将用默认的启动脚本，即：`ROOT/bin/start`进行启动。下面展示了默认启动脚本的内容。

通过命令行参数`-init_debug`可以让`init`进行在处理启动脚本时打印相应调试信息。

    % erl -init_debug
    {progress,preloaded}
    {progress,kernel_load_completed}
    {progress,modules_loaded}
    {start,heart}
    {start,error_logger}
    ...
    
启动脚本的具体内容和语法描述参见`script(4)`
  
**默认启动脚本**
  
Erlang/OTP自带了两个启动脚本：
  
- `start_clean.boot`
:    加载并启动Kernel和STDLIB
- `start_sasl.boot`
:    加载并启动Kernel、STDLIB和SASL
- `no_dot_erlang.boot`
:    加载并启动Kernel、STDLIB，但是不加载`.erlang`文件。这对于那些忽略用户自定义环境的脚本和工具非常有用。

在用`Install`安装Erlang/OTP时，程序会询问：“你希望精简启动，还是SASL启动？”，用以指定默认使用`start_clean`还是`start_sasl`启动脚本。如果你回答前者，则Erlang将用`start_clean`反之则用`start_sasl`。安装程序将复制你指定的启动脚本到`ROOT/bin`目录下，并命名为`start.boot`作为默认启动脚本。

**用户自定义启动脚本**

有时候创建自定义的启动脚本非常有用并且有必要。尤其是在嵌入式模式下运行Erlang，参见`代码加载策略(Code Loading Strategy)`。

当然你可以手动写一个启动脚本。但是最好还是用函数`systools:make_script/1,2`从发布信息文件`Name.rel`中自动生成。这样做的前提是你的程序源代码结构符合OTP的设计规范。(但是程序并不要求以OTP方式启动，可以是普通的Erlang应用)

更多关于`.erl`文件的内容参见OTP设计原理和`erl(4)`。

二进制的启动脚本`Name.boot`可以通过`systools:script2boot(File)`函数从`Name.script`中产生。

### 2.1.4 代码加载策略

Erlang可以启动为嵌入(`embedded`)或交互(`interactive`)两种模式。模式的选择通过命令行参数`-mode`指定。

    %erl -mode embedded
    
默认情况为交互模式。

- 在嵌入模式下，系统在启动时将根据启动脚本加载所有的代码。（代码可以通过显示地命令代码服务器进行延迟加载）
- 在交互模式下，代码将在第一次引用时进行加载。某个模块的函数被调用，但模块尚未加载时，代码服务器将搜索代码路径并将其加载到系统中。

初始情况下，代码路径包括当前工作路径和所有`ROOT/lib`下的代码路径，其中`ROOT`为Erlang/OTP的安装路径。路径以`Name[-Vsn]`形式命名，其中后缀`-Vsn`表示版本，并且是可选的。代码服务器将选择同一名称下版本最高的加载。代码服务器将加载`Name[-Vsn]`目录下的`ebin`文件夹。

在erl的启动参数中可以指定额外的代码路径，形式为：`-pa Directories`和`-pz Directories`。前者将路径加载到代码路径列表的开头，后者追加在最后。例如

    %erl -pa /home/arne/mycode
    
代码服务器模块`code`包含许多可以更改和检查搜索路径的函数，具体参见`code(3)`。

### 2.1.5 文件类型

Erlang/OTP中定义了如下文件类型：

| 文件类型 | 名称 / 扩展名 | 参考资料 
-----------|-------------------|-----------|
模块代码 | .erl | Erlang Reference Manual
头文件 | .hrl | Erlang Reference Manual
发布资源文件 | .rel | rel(4)
应用资源文件 | .app | app(4)
启动脚本 | .script | script(4)
二进制启动脚本 | .boot | -
配置文件 | .config | config(4)
应用升级文件 | .appup | appup(4) 
发布升级文件 | relup | relup(4)

表1.1 文件类型




  

  
  




