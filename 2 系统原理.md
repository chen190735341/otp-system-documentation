* auto-gen TOC:
{:toc}

# 2 系统原理
## 2.1 系统原理
### 2.1.1 系统启动

Erlang的运行环境(runtime system)通过命令`erl`启动：

    % erl
    Erlang/OTP 17 [erts-6.0] [hipe] [smp:8:8]
    Eshell V6.0 (abort with ^G)
    1>
    
erl有许多启动参数，具体可以参见`erl(1)`。本章将对部分参数进行介绍。

erlang应用程序可以通过函数`init:get_argument(Key)`，`init:get_arguments()`获取命令行参数。参见`init(3)`。

### 2.1.2 重启和退出

Erlang系统可以通过调用`halt/0,1`退出。参见`erlang(3)`。

`init`模块包含重新启动(restarting）、重新引导（rebooting）和停止（stopping）Erlang运行环境的函数。参见`init(3)`。

    init:restart()
    init:reboot()
    init:stop()
    
另外Erlang外壳（shell）如果停止，Erlang运行时也将停止。

### 2.1.3 启动脚本

Erlang运行环境依赖启动脚本（`boot script`）进行启动。启动脚本包含了需要加载的代码、进程和应用的指令。

启动脚本的扩展名是`.script`。Erlang系统启动是用的是二进制版本的启动脚本，它的扩展名为`.boot`。

用命令行参数`-boot`指定用哪个启动脚本启动Erlang。启动脚本的扩展名`.boot`必须省略。例如，用start_all.boot启动：

    % erl -boot start_all
    
如果没有指定启动脚本，erl将用默认的启动脚本，即：`ROOT/bin/start`进行启动。下面展示了默认启动脚本的内容。

通过命令行参数`-init_debug`可以让`init`进行在处理启动脚本时打印相应调试信息。

    % erl -init_debug
    {progress,preloaded}
    {progress,kernel_load_completed}
    {progress,modules_loaded}
    {start,heart}
    {start,error_logger}
    ...
    
启动脚本的具体内容和语法描述参见`script(4)`
  
**默认启动脚本**
  
Erlang/OTP自带了两个启动脚本：
  
- `start_clean.boot`
:    加载并启动Kernel和STDLIB
- `start_sasl.boot`
:    加载并启动Kernel、STDLIB和SASL
- `no_dot_erlang.boot`
:    加载并启动Kernel、STDLIB，但是不加载`.erlang`文件。这对于那些忽略用户自定义环境的脚本和工具非常有用。

在用`Install`安装Erlang/OTP时，程序会询问：“你希望精简启动，还是SASL启动？”，用以指定默认使用`start_clean`还是`start_sasl`启动脚本。如果你回答前者，则Erlang将用`start_clean`反之则用`start_sasl`。安装程序将复制你指定的启动脚本到`ROOT/bin`目录下，并命名为`start.boot`作为默认启动脚本。

**用户自定义启动脚本**

有时候创建自定义的启动脚本非常有用并且有必要。尤其是在嵌入式模式下运行Erlang，参见`代码加载策略(Code Loading Strategy)`。

当然你可以手动写一个启动脚本。但是最好还是用函数`systools:make_script/1,2`从发布信息文件`Name.rel`中自动生成。这样做的前提是你的程序源代码结构符合OTP的设计规范。(但是程序并不要求以OTP方式启动，可以是普通的Erlang应用)

更多关于`.erl`文件的内容参见OTP设计原理和`erl(4)`。

二进制的启动脚本`Name.boot`可以通过`systools:script2boot(File)`函数从`Name.script`中产生。

### 2.1.4 代码加载策略

Erlang可以启动为嵌入(`embedded`)或交互(`interactive`)两种模式。模式的选择通过命令行参数`-mode`指定。

    %erl -mode embedded
    
默认情况为交互模式。

- 在嵌入模式下，系统在启动时将根据启动脚本加载所有的代码。（代码可以通过显示地命令代码服务器进行延迟加载）
- 在交互模式下，代码将在第一次引用时进行加载。某个模块的函数被调用，但模块尚未加载时，代码服务器将搜索代码路径并将其加载到系统中。

初始情况下，代码路径包括当前工作路径和所有`ROOT/lib`下的代码路径，其中`ROOT`为Erlang/OTP的安装路径。路径以`Name[-Vsn]`形式命名，其中后缀`-Vsn`表示版本，并且是可选的。代码服务器将选择同一名称下版本最高的加载。代码服务器将加载`Name[-Vsn]`目录下的`ebin`文件夹。

在erl的启动参数中可以指定额外的代码路径，形式为：`-pa Directories`和`-pz Directories`。前者将路径加载到代码路径列表的开头，后者追加在最后。例如

    %erl -pa /home/arne/mycode
    
代码服务器模块`code`包含许多可以更改和检查搜索路径的函数，具体参见`code(3)`。

### 2.1.5 文件类型

Erlang/OTP中定义了如下文件类型：

| 文件类型 | 名称 / 扩展名 | 参考资料 
-----------|-------------------|-----------|
模块代码 | .erl | Erlang Reference Manual
头文件 | .hrl | Erlang Reference Manual
发布资源文件 | .rel | rel(4)
应用资源文件 | .app | app(4)
启动脚本 | .script | script(4)
二进制启动脚本 | .boot | -
配置文件 | .config | config(4)
应用升级文件 | .appup | appup(4) 
发布升级文件 | relup | relup(4)

表1.1 文件类型

## 2.2 错误日志
### 2.2.1 运行系统产生的错误信息

系统产生的错误信息记录了系统中进程未捕获的错误异常，默认情况下打印到终端(tty):

    =ERROR REPORT==== 9-Dec-2003::13:25:02 ===
    Error in process <0.27.0> with exit value: {{badmatch,[1,2,3]},[{m,f,1},{shell,eval_loop,2}]}

错误信息由`error logger`处理，它是注册名为`error_logger`的系统进程。该进程接收所有来自Erlang运行系统的错误信息，包括标准行为或Erlang/OTP的应用。

退出原因的描述(例如`badarg`参数错误)参见Erlang参考手册(Erlang Reference Manual)中的`Errors and Error Handling`。

`error_logger`进程的用户接口参见`error_logger(3)`。可以配置系统让其将错误信息写入文件中。而且用户可以通过`error_logger`定义应用产生的错误信息和其格式。

### 2.2.2 SASL 错误日志

标准进程(如`supervisor`,`gen_server`等)发送错误信息到error_logger。如果启动了SASL，这些信息也将被写入到终端。进一步阅读请移步SASL用户指南中的`SASL Error Logging`。

    % erl -boot start_sasl
    Erlang (BEAM) emulator version 5.4.13 [hipe] [threads:0] [kernel-poll]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_safe_sup}
                started: [{pid,<0.33.0>},
                        {name,alarm_handler},
                        {mfa,{alarm_handler,start_link,[]}},
                        {restart_type,permanent},
                        {shutdown,2000},
                        {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_safe_sup}
                started: [{pid,<0.34.0>},
                        {name,overload},
                        {mfa,{overload,start_link,[]}},
                        {restart_type,permanent},
                        {shutdown,2000},
                        {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_sup}
                started: [{pid,<0.32.0>},
                        {name,sasl_safe_sup},
                        {mfa,{supervisor,
                        start_link,
                        [{local,sasl_safe_sup},sasl,safe]}},
                        {restart_type,permanent},
                        {shutdown,infinity},
                        {child_type,supervisor}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_sup}
                started: [{pid,<0.35.0>},
                    {name,release_handler},
                    {mfa,{release_handler,start_link,[]}},
                    {restart_type,permanent},
                    {shutdown,2000},
                    {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            application: sasl
                started_at: nonode@nohost
    Eshell V5.4.13 (abort with ^G)
    1>
  
## 2.3 创建和升级目标系统

### 2.3.1 概述

创建Erlang/OTP应用系统最简单的方法是在特定的地方安装Erlang/OTP，并且在其他特定的地方安装程序的代码，然后启动Erlang运行系统是将应用的代码路径加入到搜索路径当中。

但是这样做常常不尽人意。一个开发者可能会为某个特定的目的开发一个Erlang/OTP应用，同时Erlang/OTP一些自带的应用在这种情况下可能变得不相关。因此，有必要根据现有的Erlang/OTP系统创建一个符合目标需求的，包含了新的应用，同时去除不相关应用的Erlang系统。那些不相关的源代码和文档也将排除在外。

本章将讨论如何创建这样的系统，我们称之为目标系统(`target system`)。

在一下章节中我们将创建具有如下不同需求能力的目标系统:

- 基本目标系统，它可以通过`erl`脚本进行启动
- 精简目标系统，系统仍然可以在运行时进行代码替换
- 嵌入式目标系统，系统仍然支持将日志输出到文件以备将来查看，同时系统将随着操作启动引导时自动启动

我们只讨论Erlang/OTP在UNIX环境下运行。

在`sasl`应用中有一个范例模块`target_system.erl`包含了创建和安装目标系统的函数。下文将使用该模块进行阐述，在本章的末尾将列出该模块的源代码。

### 2.3.2 创建目标系统

本文假设你的工作符合OTP设计规范。

**第1步**: 创建`.erl`文件(参见`rel(4)`)，文件指定`erts`的版本和需要包含的所用Erlang应用。下面是一个文件示例`mysystem.rel`：

    %% mysystem.rel
    {release,
        {"MYSYSTEM", "FIRST"},
        {erts, "5.10.4"},
        [{kernel, "2.16.4"},
            {stdlib, "1.19.4"},
            {sasl, "2.3.4"},
            {pea, "1.0"}]}.

列出的应用包含自带的Erlang/OTP应用和你自己写的新应用，如例子中的`pea`。

**第2步**: 在`mysystem.rel`所在的目录下启动Erlang/OTP系统。

    os>erl -pa /home/user/target_system/myapps/pea-1.0/ebin
    
启动时指定`pea-1.0`的ebin目录。

**第3步**: 现在创建目标系统：

    1>target_system:create("mysystem").
    
`target_system:create/1`做了如下事情：
 - 读取`mysystem.rel`文件，创建一个一模一样的`plain.rel`文件，唯一的区别是，文件之列出了`kernel`和`stdlib`应用。
 - 从`mysystem.rel`和`plain.rel`文件通过函数`systools:make_script/2`创建`mysystem.script`,`mysystem.boot`,`plain.rel`,`plain.boot`。
 - 用`systools:make_tar/2`创建打包文件`mysystem.tar.gz`。打包文件包含如下内容：


    erts-5.10.4/bin/
    releases/FIRST/start.boot
    releases/FIRST/mysystem.rel
    releases/mysystem.rel
    lib/kernel-2.16.4/
    lib/stdlib-1.19.4/
    lib/sasl-2.3.4/
    lib/pea-1.0/
    
`release/FIRST/start.boot`文件是`mysystem.boot`的副本。

打包文件中有两个`mysystem.rel`文件。刚开始，该文件值存在于`release`目录下，以便让`release_handler`可以提取它。解压之后，`release_handle`会自动将它复制到`release/FIRST`。但有时候打包文件在不包含`release_handler`的情况下解压(如，在解压第一个目标系统时)此时则有必要手动进行复制。

- 创建`tmp`临时目录，并将打包文件解压到其中。
- 删除`tmp/erts-5.10.4/bin`目录下的`erl`和`start`文件。这两个文件将在安装时自动创建。
- 创建目录`tmp/bin`
- 将先前创建的`plain.boot`文件复制到`tmp/bin/start.boot`中。
- 将`tmp/erts-5.10.4/bin`目录中的`empd`,`run_erl`和`to_erl`文件复制到`tmp/bin`目录中
- 创建`tmp/log`目录，如果系统用`bin/start`以嵌入模式启动将用到它。
- 创建`tmp/releases/start_erl.data`文件，该文件内容为“5.10.4 FIRST”。该文件将作为数据文件传递给`start_erl`脚本
- 将`tmp`下的文件重新打包成`mysystem.tar.gz`，同时删除`tmp`目录。

### 2.3.3 安装目标系统

**第4步**: 在合适的目录下安装目标系统。

    2> target_system:install("mysystem", "/usr/local/erl-target").
    
`target_system:install/2`做了如下事情：
- 将`mysystem.tar.gz`解压到目标目录`/usr/local/erl-target`中
- 读取目标目录中`release/start_erl.data`文件，以确定Erlang运行系统的版本("5.10.4")
- 将`erl.src`,`start.src`以及`start_erl.src`文件中的`%FINAL_BOOTDIR`和`%EMU`变量（分别表示`/usr/local/erl-target`和`beam`）替换为目标目录`erts-5.10.4/bin`。然后将结果文件放入目标`/bin`目录中。
- 最后从`releases/myystem.erl`创建目标文件`releases/RELEASES`。


### 2.3.4 启动目标系统

现在目标系统可以以多种方式启动。

同过如下命令启动基本目标系统

    os>/usr/local/erl-target/bin/erl

该命令只启动了`kernel`和`stdlib`，可用作如，一般的开发。这些是需要两个文件分别为`bin/erl`(来源于`erts-5.10.4、bin/erl.src`)和`bin/start.boot`文件(`plain.boot`文件的副本)。

我们也可以启动分布式系统(需要`bin/epmd`)。

如果需要启动`mysystem.rel`文件中的所有应用，用`-boot`参数按如下方式启动：

    os>/usr/local/erl-target/bin/erl -boot /usr/local/erl-target/releases/FIRST/start
    
我们用以上方式启动精简目标系统。唯一的区别在于，`releases/RELEASES`文件将用于运行时代码替换。

用`bin/start`可以启动嵌入式目标系统。该脚本调用`bin/run_erl`，它又调用了`bin/start_erl`（大体上，`start_erl`是`erl`的嵌入式变体）。

`start`脚本是在安装时从`erts-5.10.4/bin/start.src`产生的，仅仅是一个例子。你应该根据需要修改它。典型地，可以在UNIX系统引导的时候运行它。

`run_erl`简单的封装，让系统将日志输出到文件中。同时它提供了一个简单的可以连接到Erlang外壳的机制(`to_erl`)。

`start_erl`需要根目录("`user/local/erl-target`")和，发布目录("`/usr/local/erl-target/releases`")，以及`start_erl.data`文件。它从`start_erl.data`文件中读取Erlang运行系统的版本信息("5.10.4")，和发布版本("FIRST")，并用"releases/FIRST/start.boot"中指定的`-boot`参数启动运行系统。

`start_erl`同时假定发布目录("releases/FIRST/sys.config")存在`sys.config`文件。该部分内容见将在下节进行讨论。

用户最后不要修改`start_erl`脚本。

    

    
 


















  
  




