* auto-gen TOC:
{:toc}

# 2 系统原理
## 2.1 系统原理
### 2.1.1 系统启动

Erlang的运行环境(runtime system)通过命令`erl`启动：

    % erl
    Erlang/OTP 17 [erts-6.0] [hipe] [smp:8:8]
    Eshell V6.0 (abort with ^G)
    1>
    
erl有许多启动参数，具体可以参见`erl(1)`。本章将对部分参数进行介绍。

erlang应用程序可以通过函数`init:get_argument(Key)`，`init:get_arguments()`获取命令行参数。参见`init(3)`。

### 2.1.2 重启和退出

Erlang系统可以通过调用`halt/0,1`退出。参见`erlang(3)`。

`init`模块包含重新启动(restarting）、重新引导（rebooting）和停止（stopping）Erlang运行环境的函数。参见`init(3)`。

    init:restart()
    init:reboot()
    init:stop()
    
另外Erlang外壳（shell）如果停止，Erlang运行时也将停止。

### 2.1.3 启动脚本

Erlang运行环境依赖启动脚本（`boot script`）进行启动。启动脚本包含了需要加载的代码、进程和应用的指令。

启动脚本的扩展名是`.script`。Erlang系统启动是用的是二进制版本的启动脚本，它的扩展名为`.boot`。

用命令行参数`-boot`指定用哪个启动脚本启动Erlang。启动脚本的扩展名`.boot`必须省略。例如，用start_all.boot启动：

    % erl -boot start_all
    
如果没有指定启动脚本，erl将用默认的启动脚本，即：`ROOT/bin/start`进行启动。下面展示了默认启动脚本的内容。

通过命令行参数`-init_debug`可以让`init`进行在处理启动脚本时打印相应调试信息。

    % erl -init_debug
    {progress,preloaded}
    {progress,kernel_load_completed}
    {progress,modules_loaded}
    {start,heart}
    {start,error_logger}
    ...
    
启动脚本的具体内容和语法描述参见`script(4)`
  
**默认启动脚本**
  
Erlang/OTP自带了两个启动脚本：
  
- `start_clean.boot`
:    加载并启动Kernel和STDLIB
- `start_sasl.boot`
:    加载并启动Kernel、STDLIB和SASL
- `no_dot_erlang.boot`
:    加载并启动Kernel、STDLIB，但是不加载`.erlang`文件。这对于那些忽略用户自定义环境的脚本和工具非常有用。

在用`Install`安装Erlang/OTP时，程序会询问：“你希望精简启动，还是SASL启动？”，用以指定默认使用`start_clean`还是`start_sasl`启动脚本。如果你回答前者，则Erlang将用`start_clean`反之则用`start_sasl`。安装程序将复制你指定的启动脚本到`ROOT/bin`目录下，并命名为`start.boot`作为默认启动脚本。

**用户自定义启动脚本**

有时候创建自定义的启动脚本非常有用并且有必要。尤其是在嵌入式模式下运行Erlang，参见`代码加载策略(Code Loading Strategy)`。

当然你可以手动写一个启动脚本。但是最好还是用函数`systools:make_script/1,2`从发布信息文件`Name.rel`中自动生成。这样做的前提是你的程序源代码结构符合OTP的设计规范。(但是程序并不要求以OTP方式启动，可以是普通的Erlang应用)

更多关于`.erl`文件的内容参见OTP设计原理和`erl(4)`。

二进制的启动脚本`Name.boot`可以通过`systools:script2boot(File)`函数从`Name.script`中产生。

### 2.1.4 代码加载策略

Erlang可以启动为嵌入(`embedded`)或交互(`interactive`)两种模式。模式的选择通过命令行参数`-mode`指定。

    %erl -mode embedded
    
默认情况为交互模式。

- 在嵌入模式下，系统在启动时将根据启动脚本加载所有的代码。（代码可以通过显示地命令代码服务器进行延迟加载）
- 在交互模式下，代码将在第一次引用时进行加载。某个模块的函数被调用，但模块尚未加载时，代码服务器将搜索代码路径并将其加载到系统中。

初始情况下，代码路径包括当前工作路径和所有`ROOT/lib`下的代码路径，其中`ROOT`为Erlang/OTP的安装路径。路径以`Name[-Vsn]`形式命名，其中后缀`-Vsn`表示版本，并且是可选的。代码服务器将选择同一名称下版本最高的加载。代码服务器将加载`Name[-Vsn]`目录下的`ebin`文件夹。

在erl的启动参数中可以指定额外的代码路径，形式为：`-pa Directories`和`-pz Directories`。前者将路径加载到代码路径列表的开头，后者追加在最后。例如

    %erl -pa /home/arne/mycode
    
代码服务器模块`code`包含许多可以更改和检查搜索路径的函数，具体参见`code(3)`。

### 2.1.5 文件类型

Erlang/OTP中定义了如下文件类型：

| 文件类型 | 名称 / 扩展名 | 参考资料 
-----------|-------------------|-----------|
模块代码 | .erl | Erlang Reference Manual
头文件 | .hrl | Erlang Reference Manual
发布资源文件 | .rel | rel(4)
应用资源文件 | .app | app(4)
启动脚本 | .script | script(4)
二进制启动脚本 | .boot | -
配置文件 | .config | config(4)
应用升级文件 | .appup | appup(4) 
发布升级文件 | relup | relup(4)

表1.1 文件类型

## 2.2 错误日志
### 2.2.1 运行系统产生的错误信息

系统产生的错误信息记录了系统中进程未捕获的错误异常，默认情况下打印到终端(tty):

    =ERROR REPORT==== 9-Dec-2003::13:25:02 ===
    Error in process <0.27.0> with exit value: {{badmatch,[1,2,3]},[{m,f,1},{shell,eval_loop,2}]}

错误信息由`error logger`处理，它是注册名为`error_logger`的系统进程。该进程接收所有来自Erlang运行系统的错误信息，包括标准行为或Erlang/OTP的应用。

退出原因的描述(例如`badarg`参数错误)参见Erlang参考手册(Erlang Reference Manual)中的`Errors and Error Handling`。

`error_logger`进程的用户接口参见`error_logger(3)`。可以配置系统让其将错误信息写入文件中。而且用户可以通过`error_logger`定义应用产生的错误信息和其格式。

### 2.2.2 SASL 错误日志

标准型为(如`supervisor`,`gen_server`等)的进程发送错误信息到error_logger。如果启动了SASL，这些信息也将被写入到终端。进一步阅读请移步SASL用户指南中的`SASL Error Logging`。

    % erl -boot start_sasl
    Erlang (BEAM) emulator version 5.4.13 [hipe] [threads:0] [kernel-poll]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_safe_sup}
                started: [{pid,<0.33.0>},
                        {name,alarm_handler},
                        {mfa,{alarm_handler,start_link,[]}},
                        {restart_type,permanent},
                        {shutdown,2000},
                        {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_safe_sup}
                started: [{pid,<0.34.0>},
                        {name,overload},
                        {mfa,{overload,start_link,[]}},
                        {restart_type,permanent},
                        {shutdown,2000},
                        {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_sup}
                started: [{pid,<0.32.0>},
                        {name,sasl_safe_sup},
                        {mfa,{supervisor,
                        start_link,
                        [{local,sasl_safe_sup},sasl,safe]}},
                        {restart_type,permanent},
                        {shutdown,infinity},
                        {child_type,supervisor}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            supervisor: {local,sasl_sup}
                started: [{pid,<0.35.0>},
                    {name,release_handler},
                    {mfa,{release_handler,start_link,[]}},
                    {restart_type,permanent},
                    {shutdown,2000},
                    {child_type,worker}]
    =PROGRESS REPORT==== 31-Mar-2006::12:45:58 ===
            application: sasl
                started_at: nonode@nohost
    Eshell V5.4.13 (abort with ^G)
    1>
  
## 2.3 创建或升级系统

### 概述


  
  




